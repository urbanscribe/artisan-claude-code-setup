# Artisan's Claude Code Operating System

## ü§ñ What Is Artisan's Claude Code Operating System?

Artisan's Claude Code Operating System transforms Claude Code from a basic AI coding assistant into a **comprehensive professional development environment** that enforces structured project foundation, sprint lifecycle management, and enterprise-grade quality controls.

Instead of casual "jump right in" development, you get **18 specialized AI professionals** working together in a sophisticated **Global Context, Local Execution** model with **professional discipline enforcement**.

## üöÄ What This Setup Creates

**This setup establishes Artisan's Operating System that prevents the #1 cause of project failure through:**

### **Professional Project Foundation**
- **`/startprojectplanning`**: Guided project initialization with stakeholder interviews
- **Quality Gates**: No development until comprehensive foundation established
- **Structured Setup**: Vision, goals, architecture, and roadmap creation

### **Complete Sprint Operating System**
- **`/startsprintplanning`**: 5-phase planning with 10 quality gates
- **`/startnewsprint [name]`**: Create sprint with optional name and execution boundaries
- **`/implement [sprint_id]`**: Ralph Wiggum execution on active or specified sprint
- **`/endsprint`**: Professional completion with cleanup and documentation
- **`/listsprints`**: Sprint dashboard with activation controls and status management
- **`/projectstatus`**: Comprehensive project visibility and guidance

### **Enterprise-Grade Resilience**
- **`/restoreralphwiggam`**: Intelligent recovery from CLAUDE.md overwrites
- **`./setup.sh --restore`**: Out-of-band recovery preserving registry priority
- **Stateful Enforcement**: PROJECT_REGISTRY.json maintains professional integrity
- **Recovery Confidence Levels**: FULL/PARTIAL/MINIMAL restoration capabilities

### **18 Specialized AI Professionals**
1. **foundation-specialist**: Project foundation establishment
2. **sprint-planning-specialist**: Multi-phase planning orchestration
3. **recovery-specialist**: System disruption restoration
4. **cleanup-specialist**: Orphaned code detection and management
5. **discipline-enforcer**: Professional workflow enforcement
6. **planning-qa-specialist**: 10-gate quality assurance execution
7. **project-status-analyst**: Comprehensive dashboard generation
8. **user-guidance-specialist**: Contextual workflow assistance
9-18. **Core Development Skills**: coder, tester, evaluator, architect, etc.

**One command and your AI team executes complete professional workflows from foundation to production!**

---

## üèóÔ∏è ARTISAN'S OPERATING SYSTEM OVERVIEW

### **The Professional Discipline Transformation**
Artisan's Operating System prevents casual development through **enforced structured workflows**:

#### **1. Project Foundation Layer**
- **`/startprojectplanning`**: Guided initialization preventing superficial setup
- **Quality Enforcement**: Foundation required before any development work
- **Stakeholder Integration**: Vision, goals, and architecture establishment
- **Professional Setup**: Replaces "jump right in" with structured initialization

#### **2. Sprint Operating System**
- **`/startsprintplanning`**: 5-phase planning with integrated quality gates
- **`/startnewsprint`**: Execution boundary establishment with immutable manifestos
- **`/implement`**: Ralph Wiggum execution with promise tag enforcement
- **`/endsprint`**: Professional completion with cleanup and documentation
- **`/listsprints`**: Visual sprint management and status tracking
- **`/projectstatus`**: Comprehensive project visibility and guidance

#### **3. Execution Control Enhancement**
- **Ralph Wiggum Resilience**: Promise tag enforcement preventing loop failures
- **Sprint-Aware Skills**: All development skills respect manifesto boundaries
- **Iteration Management**: Safety bounds with human escalation capability
- **Boundary Enforcement**: Physical blocking of out-of-scope operations

#### **4. Recovery & Resilience**
- **`/restoreralphwiggam`**: Registry priority recovery from CLAUDE.md overwrites
- **`./setup.sh --restore`**: Out-of-band recovery preserving professional state
- **State Reconstruction**: FULL/PARTIAL/MINIMAL confidence level recovery
- **Professional Continuity**: System survives disruptions maintaining integrity

### **Three-Tier Architecture**
Artisan's Operating System follows strict architectural separation:
- **CLAUDE.md**: Absolute invariants and sovereignty rules
- **rules/sub/**: Procedural logic and workflow guidance
- **skills/**: Pure capability definitions with appropriate tool restrictions

---

## üìã COMMANDS REFERENCE

### **Project Foundation Commands**

#### `/startprojectplanning`
**Purpose**: Guided project initialization replacing casual development approach
**Workflow**: Stakeholder interviews ‚Üí keygoals.md ‚Üí architecture.md ‚Üí projectimplementationplan.md
**Quality Gates**: Foundation completeness validation
**Output**: Professional foundation establishment with structured documentation

### **Sprint Planning Commands**

#### `/startsprintplanning`
**Purpose**: 5-phase sprint planning with comprehensive quality gates
**Phases**:
1. Initial Plan Generation (APPROVE_INITIAL_DRAFT)
2. Architectural Analysis (APPROVE_ARCHITECTURAL_ANALYSIS)
3. Decision Finalization (APPROVE_FINAL_PLAN)
4. Testing Integration (APPROVE_TESTING_STRATEGY)
5. Final Validation (APPROVE_SPRINT_PLAN)
**Quality Assurance**: planning-qa-specialist executes 10-gate checklist
**Output**: Complete sprint plan with all quality gates validated

#### `/startnewsprint [optional_sprint_name]`
**Purpose**: Sprint execution boundary establishment with immutable manifesto
**Validation**: Planning checklist completed requirement
**Manifesto Creation**: Immutable token preventing "Loss of Intent"
**Boundaries**: File scope locking for professional execution isolation
**Output**: Execution-ready sprint with established boundaries

### **Execution Commands**

#### `/implement [optional_sprint_id]`
**Purpose**: Professional execution engine with Ralph Wiggum resilience
**Sprint Validation**: Active sprint and manifesto verification
**Ralph Wiggum Integration**: Promise tag enforcement (<promise>SANITY_CHECK_PASS</promise>)
**Iteration Management**: 10-iteration safety bound with human escalation
**Boundary Enforcement**: Operations restricted to manifesto scope
**Output**: Complete feature implementation with quality validation

### **Sprint Management Commands**

#### `/listsprints`
**Purpose**: Visual sprint dashboard with comprehensive management interface
**Display**: Active sprints (green), completed sprints (grey), reverse chronological
**Features**: Status indicators, quick actions, ASCII dashboard, lifecycle states
**Quick Actions**: Continue sprint, view plan, end sprint, abandon sprint
**Output**: Professional sprint management interface with actionable controls

#### `/projectstatus`
**Purpose**: Comprehensive project status dashboard for session resumption
**Sections**:
- Project Overview: Foundation status, active sprint, current phase
- Sprint Status: Phase, iteration progress, boundary enforcement
- Planning Checklist: Real-time 10-gate validation with timestamps
- Blockage Detection: Incomplete requirements identification
- Recommended Actions: Contextual next-step guidance
- Quick Stats: Sprint metrics and quality scores
**Output**: Human-readable project visibility enabling professional workflow management

#### `/endsprint`
**Purpose**: Professional sprint completion with cleanup and documentation
**Workflow**: Human acceptance ‚Üí orphaned code detection ‚Üí documentation updates ‚Üí postmortem
**Cleanup Sweep**: ls -R vs git status comparison with intelligent classification
**Documentation**: keygoals.md/architecture.md evolution with sprint learnings
**Postmortem**: Comprehensive sprint retrospective and lessons learned
**Output**: Clean sprint completion with captured knowledge and maintained hygiene

### **Recovery Commands**

#### `/restoreralphwiggam`
**Purpose**: Intelligent recovery from CLAUDE.md overwrites with registry priority
**Priority Logic**: PROJECT_REGISTRY.json ‚Üí documentation scan ‚Üí invariant reconstruction
**Recovery Levels**: FULL (complete restoration), PARTIAL (foundation rebuilt), MINIMAL (core physics)
**Promise Tags**: <promise>RECOVERED</promise>, <promise>PARTIAL</promise>, <promise>MINIMAL</promise>
**Output**: System restoration with confidence level reporting and capability assessment

---

## üèÉ PROJECT JOURNEYS - COMPLETE USER EXPERIENCES

### **Journey 1: Single Sprint Project**
```
1. /startprojectplanning     ‚Üí Establish project foundation
2. /startsprintplanning      ‚Üí Complete planning with quality gates
3. /startnewsprint user_auth ‚Üí Create & activate sprint
4. /implement               ‚Üí Execute Ralph Wiggum loops
5. /endsprint               ‚Üí Complete with cleanup
```

### **Journey 2: Multi-Sprint Project with Active Sprint Management**
```
Foundation Phase:
‚îú‚îÄ‚îÄ /startprojectplanning ‚Üí Project foundation established

Sprint 1 Planning & Execution:
‚îú‚îÄ‚îÄ /startsprintplanning ‚Üí Plan completed, all 10 gates passed
‚îú‚îÄ‚îÄ /startnewsprint user_auth ‚Üí sprint_user_auth_v1 created & ACTIVE
‚îú‚îÄ‚îÄ /implement ‚Üí Ralph Wiggum execution begins
‚îú‚îÄ‚îÄ [Work progresses to iteration 3, testing phase]

Parallel Sprint 2 Planning:
‚îú‚îÄ‚îÄ /startsprintplanning ‚Üí Plan sprint 2 while sprint 1 executes
‚îú‚îÄ‚îÄ /startnewsprint payment_flow ‚Üí sprint_payment_flow_v1 created as PLANNED
‚îú‚îÄ‚îÄ /listsprints ‚Üí Shows: user_auth (üîÑ ACTIVE), payment_flow (üìã PLANNED)

Sprint Switching:
‚îú‚îÄ‚îÄ /implement sprint_payment_flow_v1 ‚Üí Switches active sprint
‚îú‚îÄ‚îÄ sprint_user_auth_v1 ‚Üí PAUSED (progress preserved)
‚îú‚îÄ‚îÄ sprint_payment_flow_v1 ‚Üí ACTIVE, fresh execution starts

Sprint Resume:
‚îú‚îÄ‚îÄ /implement sprint_user_auth_v1 ‚Üí Switches back to paused sprint
‚îú‚îÄ‚îÄ "Resuming from iteration 3, testing phase. Continue? [Y/n]"
‚îú‚îÄ‚îÄ User: y ‚Üí Continues from exact interruption point

Completion:
‚îú‚îÄ‚îÄ /endsprint (user_auth active) ‚Üí Cleanup, postmortem, completion
‚îú‚îÄ‚îÄ Auto-prompt: "Activate sprint_payment_flow_v1? [Y/n]"
```

### **Journey 3: Sprint Interruption & Resume**
```
Active sprint: sprint_user_auth_v1 at iteration 3, coding phase

1. [System interruption - browser crash, restart, etc.]
2. /projectstatus
   ‚îú‚îÄ‚îÄ Shows: "Active Sprint: sprint_user_auth_v1"
   ‚îú‚îÄ‚îÄ "Last activity: iteration 3, coding phase"
   ‚îú‚îÄ‚îÄ "Status: Interrupted - resume available"

3. /implement
   ‚îú‚îÄ‚îÄ "Found interrupted sprint with saved progress"
   ‚îú‚îÄ‚îÄ "Resuming from iteration 3, coding phase. Continue? [Y/n]"
   ‚îú‚îÄ‚îÄ User confirms ‚Üí Continues Ralph Wiggum from coding phase
   ‚îú‚îÄ‚îÄ Completes: coding ‚Üí testing ‚Üí evaluation ‚Üí iteration 4

4. /projectstatus ‚Üí Shows resumed progress and current status
```

### **Journey 4: Planning Resume After Interruption**
```
Context: Planning interrupted during architectural analysis (phase 2/5)

1. /startsprintplanning
   ‚îú‚îÄ‚îÄ Detects: "Incomplete planning found"
   ‚îú‚îÄ‚îÄ Shows: "Last completed: initial draft"
   ‚îú‚îÄ‚îÄ "Resuming from architectural analysis phase"

2. Continues from architectural analysis:
   ‚îú‚îÄ‚îÄ Code location analysis ‚úÖ
   ‚îú‚îÄ‚îÄ Duplication elimination ‚úÖ
   ‚îú‚îÄ‚îÄ Architecture preservation ‚úÖ
   ‚îî‚îÄ‚îÄ Remaining phases complete

3. Final approval: APPROVE_SPRINT_PLAN
4. Ready for: /startnewsprint [name]
```

### **Journey 5: Disaster Recovery & System Restoration**
```
Context: CLAUDE.md accidentally overwritten, system state lost

1. /restoreralphwiggam
   ‚îú‚îÄ‚îÄ "PROJECT_REGISTRY.json intact - registry priority recovery"
   ‚îú‚îÄ‚îÄ Reconstructs CLAUDE.md invariants from registry
   ‚îú‚îÄ‚îÄ Restores all sovereignty rules and physics
   ‚îú‚îÄ‚îÄ Output: <promise>RECOVERED</promise>

2. /projectstatus
   ‚îú‚îÄ‚îÄ Shows: "System recovered - all state preserved"
   ‚îú‚îÄ‚îÄ Displays: Active sprint, foundation status, project health

3. /implement
   ‚îú‚îÄ‚îÄ Detects: "Sprint progress preserved during recovery"
   ‚îú‚îÄ‚îÄ "Resuming from last saved state. Continue? [Y/n]"
   ‚îú‚îÄ‚îÄ Continues professional development seamlessly
```

### **Active Sprint Management Principles**
- **Single Active Sprint:** Only one sprint executes Ralph Wiggum loops at a time
- **State Transitions:** planned ‚Üí active ‚Üí paused ‚Üí completed
- **Activation Methods:** `/listsprints` [Activate] or `/implement [sprint_id]`
- **Resume Safety:** Paused sprints preserve exact execution state
- **Clear Status:** `/projectstatus` always shows active sprint context
- **Switching Confirmation:** System prompts before changing active sprint

---

## ü§ñ SKILLS REFERENCE

### **Foundation & Planning Skills**

#### `foundation-specialist`
**Purpose**: Guided project foundation establishment
**Capabilities**: Stakeholder interviews, documentation creation, quality validation
**Tools**: read, grep, run_terminal_cmd (foundation-appropriate)
**Model**: opus-4.5 (complex stakeholder interactions)
**Integration**: Updates PROJECT_REGISTRY.json.foundation.complete = true

#### `sprint-planning-specialist`
**Purpose**: Multi-phase sprint planning orchestration
**Capabilities**: 5-phase workflow management, APPROVE_* gate handling, quality integration
**Tools**: read, grep, run_terminal_cmd (planning-appropriate)
**Model**: opus-4.5 (complex multi-phase orchestration)
**Integration**: Manages PROJECT_REGISTRY.json planning_checklist state

#### `planning-qa-specialist`
**Purpose**: Comprehensive planning quality assurance execution
**Capabilities**: 10-gate checklist validation, evidence-based assessment, gap identification
**Tools**: read, grep, run_terminal_cmd (validation-appropriate)
**Model**: opus-4.5 (deep architectural analysis)
**Integration**: Updates PROJECT_REGISTRY.json planning_checklist.completed

### **Execution Skills**

#### `coder`
**Purpose**: Sprint-aware code implementation with boundary enforcement
**Capabilities**: TDD execution, boundary validation, progress tracking, promise management
**Tools**: read, grep, run_terminal_cmd, edit (sprint-scoped)
**Model**: opus-4.5 (complex implementation)
**Integration**: Updates PROJECT_REGISTRY.json execution_context

#### `tester`
**Purpose**: Sprint-scoped testing with artifact isolation
**Capabilities**: Boundary-constrained testing, UI validation, artifact management, promise enforcement
**Tools**: run_terminal_cmd, grep, read (testing-appropriate)
**Model**: opus-4.5 (comprehensive validation)
**Integration**: Manages sprint-specific test artifacts and results

#### `evaluator`
**Purpose**: Sprint context evaluation with quality gate enforcement
**Capabilities**: Boundary-aware assessment, SANITY_CHECK_PASS validation, progress tracking
**Tools**: read, grep, run_terminal_cmd (evaluation-appropriate)
**Model**: opus-4.5 (architectural assessment)
**Integration**: Updates PROJECT_REGISTRY.json evaluation results

### **Support & Management Skills**

#### `recovery-specialist`
**Purpose**: Intelligent system restoration from disruptions
**Capabilities**: Registry priority analysis, state reconstruction, graceful degradation
**Tools**: read, grep, run_terminal_cmd (recovery-appropriate)
**Model**: default (reliable restoration)
**Integration**: Maintains PROJECT_REGISTRY.json integrity across recovery scenarios

#### `cleanup-specialist`
**Purpose**: Orphaned code detection and artifact management
**Capabilities**: Directory scanning, classification, human approval workflow, hygiene maintenance
**Tools**: run_terminal_cmd, read, grep (cleanup-appropriate)
**Model**: default (reliable maintenance)
**Integration**: Updates PROJECT_REGISTRY.json cleanup execution status

#### `discipline-enforcer`
**Purpose**: Professional workflow enforcement and compliance validation
**Capabilities**: Foundation gate monitoring, sovereignty enforcement, practice reinforcement
**Tools**: read (enforcement-appropriate)
**Model**: default (reliable compliance)
**Integration**: Active enforcement during all professional OS operations

#### `project-status-analyst`
**Purpose**: Comprehensive project dashboard generation
**Capabilities**: State parsing, status reporting, blockage detection, action recommendations
**Tools**: read (analysis-appropriate)
**Model**: default (reliable reporting)
**Integration**: Real-time PROJECT_REGISTRY.json interpretation

#### `user-guidance-specialist`
**Purpose**: Contextual workflow assistance and professional education
**Capabilities**: Command enhancement, error recovery guidance, workflow navigation
**Tools**: read (guidance-appropriate)
**Model**: default (reliable assistance)
**Integration**: Enhances all command outputs with contextual guidance

---

## üîÑ WORKFLOW DIAGRAMS

### **Complete Artisan Operating System Workflow**
```
FOUNDATION PHASE
/startprojectplanning
    ‚Üì (foundation.complete = true)
/startsprintplanning
    ‚Üì (APPROVE_SPRINT_PLAN)
/startnewsprint
    ‚Üì (manifesto_locked = true)
EXECUTION PHASE
/implement
    ‚Üì (SANITY_CHECK_PASS)
/endsprint
    ‚Üì (cleanup + documentation)
RECOVERY (as needed)
/restoreralphwiggam
    ‚Üì (system restoration)
MONITORING
/projectstatus, /listsprints
    ‚Üì (continuous visibility)
```

### **Sprint Planning Quality Gates**
```
Phase 1: Initial Draft ‚Üí APPROVE_INITIAL_DRAFT
Phase 2: Architectural Analysis ‚Üí APPROVE_ARCHITECTURAL_ANALYSIS
    ‚îú‚îÄ‚îÄ Goals Clarity ‚úÖ
    ‚îú‚îÄ‚îÄ Code Location ‚úÖ
    ‚îú‚îÄ‚îÄ Duplication Elimination ‚úÖ
    ‚îú‚îÄ‚îÄ Architecture Preservation ‚úÖ
    ‚îú‚îÄ‚îÄ Step-by-Step Execution ‚úÖ
    ‚îú‚îÄ‚îÄ Strategic Logging ‚úÖ
    ‚îú‚îÄ‚îÄ Dependency Management ‚úÖ
    ‚îú‚îÄ‚îÄ UI-First Design ‚úÖ
    ‚îú‚îÄ‚îÄ Architectural Decisions ‚úÖ
    ‚îî‚îÄ‚îÄ Testing Integration ‚úÖ
Phase 3: Decision Finalization ‚Üí APPROVE_FINAL_PLAN
Phase 4: Testing Strategy ‚Üí APPROVE_TESTING_STRATEGY
Phase 5: Final Validation ‚Üí APPROVE_SPRINT_PLAN
```

### **Execution Boundary Enforcement**
```
PROJECT_REGISTRY.json.sprints.active
‚îú‚îÄ‚îÄ manifesto_locked: true
‚îú‚îÄ‚îÄ locked_files: [...]
‚îî‚îÄ‚îÄ execution_context: {...}

File Operations ‚Üí Boundary Check ‚Üí ALLOWED/BLOCKED
Command Execution ‚Üí Context Validation ‚Üí ALLOWED/BLOCKED
Promise Tags ‚Üí Enforcement ‚Üí Loop Control
```

---

## üõ°Ô∏è QUALITY GATES & BLOCKING MECHANISMS

### **Foundation Gate**
**Trigger**: Any development operation when foundation.incomplete
**Mechanism**: safety_pre_tool.py blocks write/edit operations
**Resolution**: Complete /startprojectplanning
**Purpose**: Prevents #1 project failure cause

### **Planning Checklist Enforcement**
**Trigger**: /startnewsprint with incomplete planning
**Mechanism**: Validation against PROJECT_REGISTRY.json planning_checklist
**Resolution**: Complete /startsprintplanning quality gates
**Purpose**: Ensures comprehensive planning before execution

### **Sprint Boundary Enforcement**
**Trigger**: File operations outside locked_files scope
**Mechanism**: safety_pre_tool.py boundary validation
**Resolution**: Operate within manifesto boundaries
**Purpose**: Prevents scope creep and maintains execution focus

### **Ralph Wiggum Promise Enforcement**
**Trigger**: /implement execution without completion markers
**Mechanism**: Hook validation of <promise>SANITY_CHECK_PASS</promise>
**Resolution**: Generate proper completion markers
**Purpose**: Prevents 70% of execution loop failures

### **Workflow Sequence Enforcement**
**Trigger**: Out-of-order command execution
**Mechanism**: State validation in safety_pre_tool.py
**Resolution**: Follow professional workflow sequence
**Purpose**: Maintains structured development discipline

---

## üìä STATE MANAGEMENT

### **PROJECT_REGISTRY.json Structure**
```json
{
  "foundation": {
    "complete": true,
    "keygoals_hash": "a1b2c3...",
    "architecture_hash": "d4e5f6...",
    "sprint_roadmap": ["sprint_001", "sprint_002"]
  },
  "planning_checklist": {
    "completed": true,
    "validation_report": {
      "goals_clarity": {"status": "passed", "timestamp": "2026-01-10T10:30:00Z"},
      // ... 9 more gates
    },
    "final_assessment": {
      "confidence_score": 9,
      "gaps_identified": [],
      "ready_for_execution": true
    }
  },
  "sprints": {
    "active": {
      "id": "2026-01-10_sprint_001",
      "phase": "execution",
      "manifesto_locked": true,
      "locked_files": ["src/feature.py", "tests/test_feature.py"],
      "iteration": 3,
      "max_iterations": 10,
      "execution_context": {
        "current_step": "testing",
        "progress_markers": {"tests_written": true, "implementation_complete": true},
        "promise_tags_validated": ["READY_FOR_TESTER", "READY_FOR_EVALUATOR"]
      }
    },
    "history": [
      {
        "id": "2026-01-09_sprint_foundation",
        "status": "completed",
        "postmortem_path": "documentation/postmortems/2026-01-09_postmortem.md",
        "cleanup_executed": true
      }
    ]
  },
  "metadata": {
    "version": "1.0",
    "created": "2026-01-10T00:00:00Z",
    "last_modified": "2026-01-10T12:00:00Z"
  }
}
```

### **State Synchronization Requirements**
- **Every Command**: Begins with PROJECT_REGISTRY.json read
- **Status Output**: Displays "OS_STATUS: Project [Name] | Sprint [ID] | Phase [Phase]"
- **State Updates**: Commands update registry with progress and completion status
- **Integrity Checks**: Registry corruption triggers recovery mechanisms

---

## üîß SETUP & DEPLOYMENT

### **Standard Setup**
```bash
export CC_DESTINATION=/path/to/your/project
./claude_code/setup/scripts/setup.sh
```

### **Recovery Setup**
```bash
export CC_DESTINATION=/path/to/your/project
./claude_code/setup/scripts/setup.sh --restore
```

### **Post-Setup Initialization**
```bash
cd $CC_DESTINATION
/startprojectplanning    # Establish professional foundation
```

### **Verification**
- PROJECT_REGISTRY.json created and valid
- .claude/ directory with all commands and skills
- CLAUDE.md with sovereignty rules
- All hooks and safety mechanisms operational

---

## üö® TROUBLESHOOTING GUIDE

### **Common Issues**

#### **"System Lock: Project foundation not established"**
**Cause**: Attempting development before foundation completion
**Solution**: Run /startprojectplanning to establish project foundation
**Prevention**: Always complete foundation before development work

#### **"Sprint blocked: Planning checklist incomplete"**
**Cause**: Attempting sprint creation without complete planning
**Solution**: Run /startsprintplanning to complete all quality gates
**Prevention**: Ensure all 10 planning quality gates pass before sprint execution

#### **"Sprint boundary violation"**
**Cause**: File operations outside established manifesto scope
**Solution**: Operate only within sprint locked_files boundaries
**Prevention**: Review sprint manifesto before execution operations

#### **"Maximum iterations reached"**
**Cause**: Complex features exceeding 10-iteration safety bound
**Solution**: Use --escalate-iterations flag for human override
**Prevention**: Break complex features into smaller, focused sprints

#### **"Registry corruption detected"**
**Cause**: PROJECT_REGISTRY.json file corruption or loss
**Solution**: Run /restoreralphwiggam or ./setup.sh --restore
**Prevention**: Avoid manual editing of PROJECT_REGISTRY.json

### **Recovery Procedures**

#### **CLAUDE.md Overwrite Recovery**
1. Run /restoreralphwiggam
2. Verify recovery confidence level (FULL/PARTIAL/MINIMAL)
3. Check system functionality post-recovery
4. Resume professional workflow

#### **Registry Corruption Recovery**
1. Execute ./setup.sh --restore
2. Verify PROJECT_REGISTRY.json reconstruction
3. Confirm system state restoration
4. Continue with professional workflows

#### **Sprint State Recovery**
1. Check /projectstatus for current state
2. Use /listsprints to identify active sprints
3. Resume execution with appropriate commands
4. Complete sprint with /endsprint if needed

---

## üí° BEST PRACTICES & TIPS

### **Professional Workflow Discipline**
- **Always start with foundation**: /startprojectplanning prevents superficial setup
- **Complete planning thoroughly**: All 10 quality gates ensure execution success
- **Respect boundaries**: Stay within manifesto scope for focused execution
- **Use promise tags**: Proper completion markers prevent loop failures
- **Maintain hygiene**: Regular cleanup prevents artifact accumulation

### **Quality Assurance Practices**
- **TDD enforcement**: Tests first, implementation second
- **Strategic logging**: Surgical points, not excessive butter-spreading
- **Session context**: Unified get_db_session_context() usage
- **Architecture alignment**: Follow established patterns and constraints
- **Code review**: Professional evaluation before completion acceptance

### **State Management Best Practices**
- **Never edit PROJECT_REGISTRY.json manually**: Use commands for state changes
- **Regular status checks**: /projectstatus provides workflow visibility
- **Clean sprint completion**: /endsprint maintains repository hygiene
- **Recovery readiness**: Keep system recoverable with registry priority

### **Performance Optimization**
- **Work in MAIN branch**: No feature branches for professional workflows
- **Async operations**: Use async/await for proper session management
- **Dependency management**: Update pyproject.toml for proper integration
- **Minimal overhead**: Artisan's Operating System adds minimal development friction

### **Team Collaboration**
- **Shared foundation**: All team members work within established project context
- **Sprint isolation**: Concurrent sprints maintain proper boundaries
- **Documentation evolution**: Sprint completions update global knowledge
- **Postmortem reviews**: Lessons learned improve future sprint execution

---

## üéØ CONCLUSION

Artisan's Claude Code Operating System transforms AI-assisted development from casual experimentation into **enterprise-grade professional workflows**. Through enforced project foundation, comprehensive sprint management, quality gate enforcement, and intelligent recovery, the system prevents the major causes of project failure while maintaining the flexibility and power of AI assistance.

**The result**: A development environment where professional discipline is invisible yet omnipresent, enabling teams to deliver high-quality software through structured, repeatable processes that scale from individual developers to enterprise teams.

**Ready for professional development excellence.** üöÄ‚ú®

### **Sprint Engine Benefits**
- **üéØ Focused Work**: Each sprint has clear goals and boundaries
- **üîÑ Iterative Improvement**: Ralph Wiggum loops ensure perfection
- **üõ°Ô∏è Quality Assurance**: Reality Auditor prevents false victories
- **üìä Progress Tracking**: Always know where you stand
- **üîí Safety First**: Enterprise-grade security and isolation
- **üë• Team Scaling**: Multiple sprints can run in parallel

---

## üéÅ What You Get

### **12 AI Specialists with Sprint Focus**
- **Planner**: Creates sprint plans with hydration validation
- **Coder**: Writes code within sprint boundaries
- **Tester**: Tests with sprint-scoped validation
- **Evaluator**: Reviews with confidence scoring
- **Sanity Checker**: Reality Auditor for UI/data integrity
- **Architect Reviewer**: Ensures architectural consistency
- **QA Enforcer**: Eliminates open architectural choices
- **UI Validator**: Tests visual regression and accessibility
- **Dependency Researcher**: Evaluates external libraries
- **Self-Assessor**: Automated quality scoring (0-100)
- **Skeptic**: Challenges assumptions with evidence
- **Async Optimizer**: Performance and concurrency optimization

### **Sprint Engine Infrastructure**
- **SPRINT_STATE.json**: Automatic sprint lifecycle management
- **Sprint Discovery**: Intelligent active sprint identification
- **Artifact Management**: Organized temp storage with cleanup
- **Boundary Enforcement**: Stateful fail-closed security
- **Context Pruning**: Clean phase transitions with manifesto generation

### **Global Context, Local Execution**
- **Smart Memory (CLAUDE.md)**: <15 lines of absolute invariants
- **Three-Tier Rules System**: CLAUDE.md ‚Üí 7 main rules ‚Üí 16 sub-rules
- **Plan Hydration**: Automatic context pulling with validation gates
- **Stateful Enforcement**: Worktree isolation and repair scope locking
- **Context Reset Protocol**: Manifesto generation between phases

### **Enterprise-Grade Quality**
- **Ralph Wiggum Loops**: Iterative perfection with progress tracking
- **Reality Auditor**: Prevents "Victory Too Early" with SANITY_CHECK_PASS
- **Data Integrity Rubrics**: Nonsense prevention for UI/API features
- **Hook Denial Recovery**: Graceful handling of security blocks
- **Audit Logging**: Complete operation traceability

### **Human-Centric Design**
- **Approval Gates**: Human control at all major decisions
- **Context Pruning**: Mandatory /clear for memory management
- **Progress Transparency**: Real-time sprint status and completion tracking
- **Error Recovery**: Self-healing with human escalation paths
- **Parallel Development**: Multiple sprints with safe coordination

---

## ‚úÖ BEFORE YOU START

### 1. Install Claude Code

You need Claude Code installed first. It's separate from regular Claude AI.

```bash
# Install Claude Code
curl -fsSL https://claude.ai/install.sh | bash

# Verify it works
claude --help
```

**Need help?** Visit [Claude Code documentation](https://docs.anthropic.com/claude/docs/claude-code) for detailed installation instructions.

### 2. Choose Your Project

**New Project?** Start with an empty directory
**Existing Project?** Use your current project directory

Both work perfectly with this setup!

---

## üì• QUICK START: Get Your AI Team Running in 5 Minutes

### Step 1: Clone This Repository
```bash
# Clone the setup repository (you can rename it if you want)
git clone <repository-url> claude-code-setup
cd claude-code-setup
```

### Step 2: Tell Us Where Your Project Is
```bash
# Set this to the folder where you want to use Claude Code
# This is your actual project directory (existing or new)
export CC_DESTINATION=/path/to/your/actual/project

# Example: If your project is in ~/my-app
export CC_DESTINATION=~/my-app
```

### Step 3: Run Setup
```bash
# Run the setup script from within this cloned repository
./scripts/setup.sh
```

**That's it!** Your AI team is now ready in your project directory.

### Step 4: Start Using Your AI Team
```bash
# Go to your project directory
cd "$CC_DESTINATION"

# Start Claude Code
claude

# Create your first sprint
/implement "build a user login system"
```

---

## ü§ñ INTERACTIVE SETUP (Guided Installation)

**Want the setup to ask you questions and customize for your project?**

```bash
# From within the cloned repository
./scripts/setup-interactive.sh
```

**What the script will ask you:**
- **Project type**: "Are you setting up for a NEW project or EXISTING project?"
- **Project location**: "What is the full path to your project directory?"
- **Existing docs**: "Does your project have existing documentation? (Y/n)"
- **Documentation path**: "Where is your documentation folder? [docs]"
- **Tech stack**: "What is your primary tech stack? [Python]"
- **Git usage**: "Is this project using Git? (Y/n)"
- **Worktree isolation**: "Do you want worktree isolation? (Y/n)"
- **Debug mode**: "Enable debug mode? (y/N)"
- **Enterprise features**: "Enable enterprise security features? (Y/n)"
- **Audit logging**: "Enable audit logging? (Y/n)"

**Your responses guide the customization:**
- **New vs Existing**: Determines if docs folder is created or integrated
- **Project path**: Where the AI team files get installed
- **Tech stack**: Influences default configurations
- **Security options**: Enables enterprise-grade safety features

**Takes about 3-5 minutes** with questions and customization.

---

## üöÄ AUTOMATED SETUP (Quick & Simple)

**Want it done in 30 seconds with no questions?**

```bash
# From within the cloned repository
export CC_DESTINATION=/path/to/your/project  # Set your project path
./scripts/setup.sh
```

**What happens automatically:**
- ‚úÖ Copies CLAUDE.md to your project
- ‚úÖ Creates `.claude/` directories and files
- ‚úÖ Sets up 12 AI specialists and rules system
- ‚úÖ Configures security and permissions
- ‚úÖ Initializes sprint infrastructure

---

## üèóÔ∏è THREE-TIER RULES SYSTEM

Your AI team operates within a sophisticated hierarchical rules system that ensures consistency, quality, and efficiency:

### Core Layer: CLAUDE.md (Absolute Invariants)
**What it contains**: Non-negotiable physics-level rules that cannot change
- Database integrity (no resets/drops/duplicates, use get_db_session_context())
- Git safety (no writes, read-only operations only)
- Human sovereignty (architectural decisions require approval)
- Worktree boundaries (agents stay within project scope)

### Main Rules Layer: 7 Task-Specific Rules
**When loaded**: Conditionally based on workflow phase and task requirements

#### Planning & Discovery Rules
- **`project-discovery.md`** - Forces ingestion of existing architectural docs before planning
- **`tdd-enforcer.md`** - Ensures test-driven development gates throughout workflow

#### Architecture & Quality Rules
- **`dependency-integrator.md`** - Manages external libraries and API integrations
- **`architect-reviewer.md`** - Validates architectural consistency and patterns
- **`confidence-booster.md`** - Automated quality improvement for low-confidence outputs

#### Implementation Rules
- **`checklist-polisher.md`** - Applies comprehensive quality checklists
- **`cover-letter-generator.md`** - Creates dev handoffs for Ralph Wiggum loops

### Sub-Rules Layer: 16 Detailed Specializations
**When loaded**: Only when specific conditions are met, minimizing token usage

#### Development Standards
- **`core_invariants.md`** - Operational procedures (async patterns, logging, error handling)
- **`tdd_examples.md`** - Test structure templates and patterns
- **`async_patterns.md`** - Concurrency and performance optimization
- **`arch_basics.md`** - Fundamental architectural patterns

#### Quality Assurance
- **`confidence_check.md`** - 0-100 scoring rubric for output validation
- **`common_checks.md`** - Shared validation patterns (logging, errors, performance)
- **`polish_checklist.md`** - Comprehensive quality improvement checklists
- **`phase_markers.md`** - Standardized markers for plan progression

#### External Integration
- **`dependency_licenses.md`** - License compatibility validation
- **`dependency_security.md`** - Security vulnerability assessment
- **`external_verification.md`** - API and external service validation

#### UI & Testing
- **`ui_debug_modes.md`** - Browser testing and debug configurations
- **`tool_wildcards.md`** - Advanced tool permission patterns
- **`error_patterns.md`** - Error handling and recovery patterns
- **`doc_revision_rules.md`** - Documentation update guidelines
- **`hook-denial-recovery.md`** - Security violation response protocols

### How the Rules System Works
1. **CLAUDE.md loads automatically** - Core invariants available in every session
2. **Main rules load conditionally** - Based on workflow phase (planning, implementation, etc.)
3. **Sub-rules load on-demand** - Only when specific expertise needed
4. **Token efficiency** - Rules load hierarchically to minimize context usage
5. **Quality enforcement** - Rules ensure architectural consistency and code quality

---

## üéØ CHOOSE YOUR SETUP METHOD

**Two ways to get started - pick what works best for you:**

### ü§ñ OPTION 1: INTERACTIVE SETUP (Recommended for beginners)
**Guided setup that asks questions and customizes for your project**

```bash
./scripts/setup-interactive.sh
```

**Best for:**
- First-time users
- Complex projects with existing documentation
- Teams that want personalized guidance

**Takes:** 3-5 minutes with questions

### üöÄ OPTION 2: AUTOMATED SETUP (Quick & simple)
**One-command installation with no questions**

```bash
export CC_DESTINATION=/path/to/your/project
./scripts/setup.sh
```

**Best for:**
- Experienced users
- CI/CD automation
- Simple projects

**Takes:** 30 seconds

---

## üìã DETAILED SETUP BY PROJECT TYPE

### IF YOU ARE STARTING A BRAND NEW PROJECT

**Perfect! This setup will create your entire project structure and initialize all architectural documentation.**

#### Step-by-Step New Project Setup

1. **Clone the Repository**
   ```bash
   git clone <repository-url> claude-code-setup
   cd claude-code-setup
   ```

2. **Create Your Project Directory**
   ```bash
   # Create your actual project folder (outside this setup repo)
   mkdir ~/my-new-project
   cd ~/my-new-project
   git init  # Initialize as git repository
   ```

3. **Run Setup from the Cloned Repository**
   ```bash
   # Go back to the setup repository
   cd ~/claude-code-setup

   # Set destination to your new project
   export CC_DESTINATION=~/my-new-project

   # Run the setup
   ./scripts/setup.sh
   ```

4. **Initialize Project Architecture**
   ```bash
   # Go to your project
   cd ~/my-new-project

   # Start Claude Code
   claude

   # Initialize your project architecture
   /implement "Initialize project architecture for a web application"
   ```

5. **Complete Initial Setup**
   - Follow the approval prompts (APPROVE_PLAN, etc.)
   - Use `/clear` when instructed for memory management
   - The system will create your architectural foundation

**Result**: Complete project with AI team, architectural docs, and development environment ready.

---

### IF YOU ARE ADDING THIS SETUP TO AN EXISTING PROJECT

**Great! This setup will integrate with your existing code and documentation.**

#### Step-by-Step Existing Project Integration

1. **Clone the Setup Repository**
   ```bash
   git clone <repository-url> claude-code-setup
   cd claude-code-setup
   ```

2. **Navigate to Your Existing Project**
   ```bash
   # Go to your actual project (keep setup repo separate)
   cd /path/to/your/existing/project
   # Make sure you're in a git repository
   git status  # Verify git is initialized
   ```

3. **Prepare Your Documentation (Optional)**
   If you have existing architectural docs, copy them to the expected location:
   ```bash
   # Create the documentation structure
   mkdir -p documentation/main

   # Copy your existing docs (if any)
   cp your-existing-architecture.md documentation/main/proposedarchitecture.md
   cp your-existing-api-docs.md documentation/main/
   # Add any other architectural documents
   ```

4. **Run Setup from the Cloned Repository**
   ```bash
   # Go back to the setup repository
   cd ~/claude-code-setup

   # Set destination to your existing project
   export CC_DESTINATION=/path/to/your/existing/project

   # Run the setup (it will preserve your existing files)
   ./scripts/setup.sh
   ```

5. **Knowledge Collection & Integration**
   ```bash
   # Go to your project
   cd /path/to/your/existing/project

   # Start Claude Code
   claude

   # Use the knowledge collection command to ingest your existing docs
   /collect-knowledge "Integrate existing project documentation and codebase"

   # Or use implement for a comprehensive integration
   /implement "Integrate Claude Code team with existing API project"
   ```

6. **Verify Integration**
   - Check that your existing docs are referenced in plans
   - Confirm the AI team understands your architecture
   - Test with a small feature addition

**Result**: Your existing project enhanced with AI team capabilities while preserving all current work.

---

## üèÉ‚Äç‚ôÇÔ∏è WORKING WITH SPRINTS: Complete Development Lifecycle

### **Sprint Engine for Beginners**

The Sprint Engine manages development in focused, time-boxed cycles. Think of each sprint as a "development story" with clear beginning, middle, and end.

#### **Phase 1: Sprint Planning (Set Your Goals)**
**What happens**: AI team analyzes your request and creates a detailed plan
**What you do**: Review and approve the plan
**Commands**:
```bash
/implement "build a user login system"
/hydrate-plan  # (automatically runs) pulls global context
APPROVE_PLAN   # Type this when ready
```

#### **Phase 2: Sprint Execution (Build the Feature)**
**What happens**: AI team writes code, tests, and validates
**What you do**: Approve at quality gates, use `/clear` when prompted
**What you'll see**:
```
üßπ Memory cleared. Ready for next phase.
‚ö†Ô∏è HUMAN APPROVAL NEEDED: APPROVE_CODE_WRITE
üîÑ Ralph Wiggum: Entering iterative refinement mode
‚úÖ READY_FOR_TESTER (iteration 1)
üß™ Testing phase...
‚úÖ SANITY_CHECK_PASS - UI validation complete
üéâ EVALUATION_COMPLETE - Feature ready!
```

#### **Phase 3: Sprint Completion (Wrap Up & Learn)**
**What happens**: AI captures learnings, updates global documentation
**What you do**: Review final results
**Commands**:
```bash
/close-sprint  # Marks sprint complete, triggers updates
```

### **Sprint Lifecycle Best Practices**

#### **üéØ Start Small, Think Big**
- **First Sprint**: Start with something simple like "add a contact form"
- **Build Confidence**: Each successful sprint teaches you the flow
- **Scale Up**: Use learnings to tackle bigger features

#### **üìù Plan Your Sprints**
- **Clear Descriptions**: "build user registration with email verification" (good)
- **Avoid Vague**: "make the app better" (too vague)
- **Scope Appropriately**: One main feature per sprint
- **Include Context**: Mention existing features to integrate with

#### **üîÑ Master the Approval Flow**
```bash
# Pattern: Command ‚Üí Review ‚Üí Approve ‚Üí Clear ‚Üí Continue
/implement "your feature"
/* READ the generated plan carefully */
/* ASK questions if anything unclear */
APPROVE_PLAN
/clear  # Always do this when prompted!
/* Continue with next approvals */
APPROVE_CODE_WRITE
/clear
APPROVE_EVALUATION
```

#### **üß† Context Management is Critical**
- **`/clear` is your friend**: Always type it when Claude prompts
- **Why it matters**: Prevents confusion between planning and coding
- **What happens**: Fresh start with only current phase context
- **When forgotten**: Claude might mix up ideas from different phases

#### **üìä Monitor Progress**
- **Check Status**: Files appear in `documentation/plans/`
- **Watch for Signals**:
  - ‚úÖ `READY_FOR_TESTER` - Code implementation complete
  - ‚úÖ `SANITY_CHECK_PASS` - UI/Data validation successful
  - ‚úÖ `EVALUATION_COMPLETE` - Sprint finished successfully
  - üîÑ `Ralph Wiggum: Entering iterative refinement` - Auto-improvement active

#### **üö® Handle Issues**
- **Stuck?**: Use `/repair "describe the problem"`
- **Complex debugging**: Use `/debug-issue "problem description"`
- **Plan validation**: Use `/test-plan` before major approvals
- **Wrong direction**: `/abandon-sprint` and start over

#### **üë• Scale to Multiple Features**
```bash
# Terminal 1: Backend sprint
/implement "build API endpoints"
/close-sprint

# Terminal 2: Frontend sprint (new terminal)
/clear
/implement "build user interface"
```

#### **üìö Learn from Each Sprint**
- **Review Results**: Check what was built in `temp/claudecode/[sprint_id]/`
- **Read Updates**: See how global docs improved in `documentation/main/`
- **Build Knowledge**: Each sprint makes the AI team smarter about your project

### **Sprint Engine Mindset**

#### **Think in Stories**
- Each sprint tells a complete development story
- Beginning: Clear requirements and planning
- Middle: Focused execution with quality gates
- End: Production-ready feature with documentation updates

#### **Trust the Process**
- **AI handles complexity**: You focus on direction and approvals
- **Quality is built-in**: Automated testing and validation
- **Mistakes are caught**: Multiple review layers prevent issues
- **Learning happens**: Each sprint improves the system

#### **Human + AI Partnership**
- **You provide**: Direction, approvals, business context
- **AI provides**: Technical execution, quality assurance, consistency
- **Together**: Professional-grade software development

---

## ü§ñ INTERACTIVE SETUP (Guided Installation)

**Want the setup to ask you questions and customize based on your project? Use the interactive script!**

```bash
# Run the interactive setup script
./scripts/setup-interactive.sh
```

**What it does:**
- ‚úÖ **Asks about your project type** (new or existing)
- ‚úÖ **Gathers project information** (tech stack, documentation location, etc.)
- ‚úÖ **Customizes the installation** based on your answers
- ‚úÖ **Sets up documentation structure** intelligently
- ‚úÖ **Provides personalized guidance** for next steps

**Perfect for:**
- First-time users who want guidance
- Complex projects with custom documentation structures
- Teams that want tailored setup recommendations

**Takes about 3-5 minutes** with questions and customization.

**Example interaction:**
```bash
$ ./scripts/setup-interactive.sh

üöÄ CLAUDE CODE INTERACTIVE SETUP
This guided setup will ask you questions...

‚ùì Are you setting up Claude Code for a NEW project or EXISTING project? [existing]: existing
‚ùì What is the full path to your project directory? [/current/path]:
‚ùì Does your project have existing documentation? [Y/n]: y
‚ùì Where is your documentation folder? [docs]: docs/api
‚ùì What is your primary tech stack? [Python]: Python/FastAPI
‚ùì Is this project using Git? [Y/n]: y
‚ùì Do you want worktree isolation for parallel development? [Y/n]: y
‚ùì Enable debug mode for development? [y/N]: n
‚ùì Enable enterprise security features? [Y/n]: y
‚ùì Enable comprehensive audit logging? [Y/n]: y

‚úÖ Setup completed successfully!
```

---

## üöÄ AUTOMATED SETUP (Works for Both New & Existing Projects)

**Want it done in 30 seconds with no questions? Use the automated script!**

```bash
# 1. Clone the setup repository
git clone <repository-url> claude-code-setup
cd claude-code-setup

# 2. Set your project location
export CC_DESTINATION=/path/to/your/project  # New or existing project folder

# 3. Run the automated setup
./scripts/setup.sh
```

**What it does automatically:**
- ‚úÖ Copies CLAUDE.md (project memory)
- ‚úÖ Creates all `.claude/` folders and files
- ‚úÖ Sets up 12 AI specialists and complete three-tier rules system (7 main + 16 sub-rules)
- ‚úÖ Creates documentation structure
- ‚úÖ Preserves existing files in existing projects
- ‚úÖ Sets proper permissions and security

---

## üìã AVAILABLE COMMANDS & WHEN TO USE THEM

### `/implement "feature description"` - MAIN WORKFLOW COMMAND
**When to use**: For building complete features from start to finish
**Why use it**: Orchestrates the entire AI team through planning ‚Üí coding ‚Üí testing ‚Üí evaluation
**What it does**:
- Planner creates detailed implementation plan
- Coder writes production-ready code with tests
- Tester validates with real data and browsers
- Evaluator ensures quality standards
- Human approval gates at each major phase
**Example**: `/implement "add user authentication with email verification"`
**When NOT to use**: For quick fixes or debugging (use `/repair` or `/debug-issue` instead)

### `/repair "what broke"` - TARGETED FIX COMMAND
**When to use**: When something specific is broken and needs fixing
**Why use it**: Provides scoped repair with strict boundaries to prevent unintended changes
**What it does**:
- Isolates the exact problem area
- Applies surgical fixes only within approved scope
- Re-tests the specific functionality
- Maintains data integrity and prevents side effects
**Example**: `/repair "login form validation not working in Firefox"`
**When NOT to use**: For new feature development (use `/implement` instead)

### `/test-plan` - PLAN VALIDATION COMMAND
**When to use**: Before approving implementation to ensure plan quality
**Why use it**: Catches architectural issues, missing requirements, and quality problems early
**What it does**:
- Validates plan completeness and structure
- Checks architectural compliance
- Verifies TDD requirements and testing strategy
- Ensures database safety and human control points
**Example**: `/test-plan` (validates the current PLAN.md in documentation/plans/)
**When NOT to use**: During active development (use as pre-approval check)

### `/debug-issue "problem description"` - SYSTEMATIC DEBUGGING COMMAND
**When to use**: When you need structured debugging with browser verification
**Why use it**: Provides comprehensive debugging methodology beyond basic troubleshooting
**What it does**:
- Enables debug mode and strategic logging
- Reproduces issues with systematic testing
- Uses browser verification and console analysis
- Applies targeted fixes with validation
**Example**: `/debug-issue "API calls failing after deployment"`
**When NOT to use**: For simple syntax errors (ask Claude directly)

### `/collect-knowledge` - KNOWLEDGE INTEGRATION COMMAND
**When to use**: When adding this setup to existing projects with documentation
**Why use it**: Ensures the AI team understands your existing architecture and codebase
**What it does**:
- Reads all files in `documentation/main/`
- Analyzes existing architectural decisions
- Builds context about your project's patterns and conventions
- Makes this knowledge available to all AI team members
**Example**: `/collect-knowledge "Ingest existing project documentation and architectural decisions"`
**When NOT to use**: For new projects (knowledge collection happens automatically during `/implement`)

### `/create-sprint` - SPRINT INITIALIZATION COMMAND
**When to use**: To start a new focused development cycle
**Why use it**: Sets up sprint boundaries, generates global context hash, and initializes state tracking
**What it does**:
- Creates unique sprint ID with timestamp
- Generates SHA256 hash of global documentation
- Initializes SPRINT_STATE.json with boundaries
- Sets up temp directory for sprint artifacts
**Example**: `/create-sprint "build user authentication system"`
**When NOT to use**: During active sprint (use `/switch-sprint` instead)

### `/list-sprints` - SPRINT STATUS COMMAND
**When to use**: To see all sprints and their current status
**Why use it**: Provides overview of development progress and sprint history
**What it does**:
- Shows active sprint with detailed status
- Lists completed and abandoned sprints
- Displays global context synchronization status
- Provides interactive sprint selection guidance
**Example**: `/list-sprints`
**When NOT to use**: When you need to take action (use specific commands instead)

### `/switch-sprint` - SPRINT CONTEXT SWITCHING COMMAND
**When to use**: To change which sprint you're currently working on
**Why use it**: Safely transitions between different development contexts
**What it does**:
- Validates sprint ID and state integrity
- Performs global context reconciliation
- Updates active sprint in SPRINT_STATE.json
- Handles hash mismatch resolution
**Example**: `/switch-sprint 2026-01-09_plan_003_user_auth`
**When NOT to use**: During critical sprint execution (complete current first)

### `/close-sprint` - SPRINT COMPLETION COMMAND
**When to use**: When a sprint is finished and ready for delivery
**Why use it**: Properly completes sprint with handoff and cleanup
**What it does**:
- Performs orphaned code detection
- Triggers architectural evolution updates
- Updates global documentation with learnings
- Finalizes sprint state and moves to history
**Example**: `/close-sprint`
**When NOT to use**: If sprint isn't truly complete (use `/abandon-sprint` instead)

### `/abandon-sprint` - SPRINT CANCELLATION COMMAND
**When to use**: When a sprint needs to be stopped before completion
**Why use it**: Cleanly cancels sprint while preserving artifacts for future reference
**What it does**:
- Documents abandonment reason
- Preserves all artifacts in organized storage
- Updates sprint state to abandoned
- Captures lessons learned for future sprints
**Example**: `/abandon-sprint`
**When NOT to use**: For completed work (use `/close-sprint` instead)

### Step 5: Quick Command Reference

| Command | Purpose | When to Use |
|---------|---------|-------------|
| `/implement "feature"` | **Build complete features** - Full AI team workflow | New development, major features |
| `/repair "issue"` | **Fix specific problems** - Scoped, surgical fixes | Bug fixes, targeted improvements |
| `/debug-issue "problem"` | **Systematic debugging** - Browser testing, root cause analysis | Complex issues, performance problems |
| `/test-plan` | **Plan validation** - Quality check before implementation | Plan review, pre-approval |
| `/collect-knowledge "context"` | **Project integration** - Learn existing architecture | Adding to existing projects |

### Step 6: Understanding Ralph Wiggum - The Iterative Refinement System

**Ralph Wiggum is your AI team's secret weapon for perfection!** üîÑ

#### How It Works
After initial implementation, Claude enters **iterative improvement mode**:

```
Planning ‚Üí Initial Code ‚Üí Ralph Loop ‚Üí Perfection
                      ‚Üì
               üîÑ ITERATE UNTIL PERFECT üîÑ
                      ‚Üì
            Testing ‚Üí Fixing ‚Üí Re-testing
```

#### What You'll See
**Progress Tracking:**
```
ü§ñ Starting feature implementation...
üìã PLAN CREATED: documentation/plans/plan_001.md
‚ö†Ô∏è Type: APPROVE_PLAN
[... planning phases ...]
üíª Code implementation starting...
üîÑ Ralph Wiggum: Entering iterative refinement mode
üìä Progress: temp/progress.txt updated
‚úÖ READY_FOR_TESTER (iteration 1)
üß™ Testing phase...
‚ö†Ô∏è Issues found, auto-correcting...
‚úÖ READY_FOR_TESTER (iteration 2)
üîÑ Ralph continues until perfect...
üéâ EVALUATION_COMPLETE - Feature ready!
```

#### The Promise/Done Protocol
- **Promise**: "I will implement this feature perfectly"
- **Working**: Active coding and refinement
- **Done**: Feature meets all quality standards
- **Progress**: Tracked in `/temp/progress.txt`

#### Human Control Points
- **Iteration Limits**: Max 50 cycles, human intervention at 40
- **Quality Gates**: Must pass confidence scoring (‚â•80)
- **Escalation**: Human approval for complex issues
- **Memory Management**: `/clear` commands prevent context drift

#### When Ralph Wiggum Activates
- ‚úÖ After initial `/implement` planning phases
- ‚úÖ During complex feature development
- ‚úÖ When quality issues are detected
- ‚úÖ For performance optimization needs

**Ralph Wiggum means you get enterprise-quality results with minimal human intervention!** üéØ

---

## üß† KNOWLEDGE MANAGEMENT SYSTEM

### How the AI Team Learns About Your Project

**For New Projects:**
- The `/implement` command automatically initializes architectural documentation
- AI team creates `documentation/main/` folder with project-specific docs
- Knowledge builds organically as you develop features

**For Existing Projects:**
- Use `/collect-knowledge` to ingest your existing documentation
- Place architectural docs in `documentation/main/` folder
- The AI team reads these files during planning phases

### Key Documentation Locations:
```
documentation/main/
‚îú‚îÄ‚îÄ proposedarchitecture.md    # Core architectural decisions
‚îú‚îÄ‚îÄ [api-docs].md             # API patterns and conventions
‚îú‚îÄ‚îÄ [data-models].md          # Database schemas and patterns
‚îî‚îÄ‚îÄ [domain-rules].md         # Business logic and constraints
```

### Knowledge Persistence:
- **CLAUDE.md**: Core invariants loaded every session
- **Rules System**: Hierarchical guidance (core ‚Üí main ‚Üí sub-rules)
- **Architectural Docs**: Project-specific patterns and decisions
- **Session Context**: Maintained within individual Claude sessions

---

## QUICK START CHECKLIST

**For New Projects:**
- [ ] Create project directory and `git init`
- [ ] Set `CC_DESTINATION` and run setup script
- [ ] Run `/implement "Initialize project architecture"`
- [ ] Follow approval prompts and memory management

**For Existing Projects:**
- [ ] Navigate to existing project
- [ ] Copy architectural docs to `documentation/main/`
- [ ] Set `CC_DESTINATION` and run setup script
- [ ] Run `/collect-knowledge` then `/implement` for integration

**Both Scenarios:**
- [ ] Verify `.claude/` directory structure created
- [ ] Test basic command: `/implement "create a simple hello world page"`
- [ ] Learn the approval flow and `/clear` usage

**üí° MUCH EASIER**: Skip all manual steps! Use the automated setup script instead (see the üöÄ AUTOMATED SETUP section below).

## Step-by-Step Setup (Copy These Files)

### Step 4: Copy the AI Team Instructions
Copy the files that define how each AI specialist behaves.

**Where to put them**: `.claude/skills/` (the skills folder you created)
```bash
# Copy all 12 AI specialist instruction files
cp /path/to/this/setup/.claude/skills/*.md .claude/skills/
```

**What each specialist does**:
- `planner.md` - Creates sprint plans with hydration validation
- `coder.md` - Writes code within sprint boundaries
- `tester.md` - Tests with sprint-scoped validation
- `evaluator.md` - Reviews with confidence scoring
- `sanity-checker.md` - Reality Auditor for UI/data integrity
- `architect-reviewer.md` - Ensures architectural consistency
- Plus 6 more specialists for QA, research, optimization, etc.

### Step 5: Copy Safety Guards
Copy the safety check programs that run automatically before and after Claude Code does anything.

**Where to put them**: `.claude/hooks/` (the hooks folder you created)
```bash
# Copy the safety programs (from the setup repository)
cp /path/to/setup/repo/.claude/hooks/*.py .claude/hooks/

# Make them executable (able to run)
chmod +x .claude/hooks/*.py
```

**What each guard does**:
- `safety_pre_tool.py` - Checks before Claude does anything risky (like deleting files)
- `validation_post_tool.py` - Checks after work is done and catches problems

### Step 6: Copy Special Commands
Copy the custom commands you can type to make the AI team do specific jobs.

**Where to put them**: `.claude/commands/` (the commands folder you created)
```bash
# Copy the command definitions (from the setup repository)
cp /path/to/setup/repo/.claude/commands/*.md .claude/commands/
```

**Commands you can use**:
- `/implement "feature description"` - **PRIMARY**: Builds complete features from planning to deployment
- `/repair "what broke"` - **TARGETED**: Fixes specific issues with surgical precision
- `/test-plan` - **VALIDATION**: Checks plan quality before implementation approval
- `/debug-issue "problem"` - **DEBUGGING**: Systematic debugging with browser verification
- `/collect-knowledge "description"` - **INTEGRATION**: Ingests existing project docs for existing projects

### Step 7: Copy Permission Settings
Copy the settings file that controls what Claude Code can and cannot do automatically.

**Where to put it**: `.claude/settings.json` (in the .claude folder)
```bash
# Copy the permission settings (from the setup repository)
cp /path/to/setup/repo/.claude/settings.json .claude/settings.json
```

**What this controls**:
- Which actions Claude can do without asking (like reading files)
- Which actions need your approval (like changing code)
- Which safety checks run automatically

### Step 8: Create Extra Folders
Make the folders where plans and tests will be stored.

```bash
# Create folders for plans and test scripts
mkdir -p documentation/plans tests/poc_scripts

# Make sure all .claude files can be read/executed
chmod -R 755 .claude/
```

**What these folders are for**:
- `documentation/plans/` - Where the AI team saves their detailed plans
- `tests/poc_scripts/` - Where quick test programs go to verify ideas

## Why This Setup Is Special

This setup uses advanced techniques from the creators of Claude AI:

### Smart Memory System
- **CLAUDE.md**: Automatically loads all your project rules every time
- **No need to repeat instructions**: Claude "remembers" your preferences
- **Faster development**: No explaining rules over and over

### Architectural Documentation
- **Source of Truth**: `/documentation/main/` contains your project's architectural decisions
- **Always Current**: Agents read and update these docs as they work
- **Consistency Guarantee**: Every feature aligns with established patterns
- **Living Documentation**: Architecture evolves with your project

### Team Coordination
- **4 AI specialists**: Each handles one job (plan, code, test, review)
- **They work together**: Hand off work automatically like real developers
- **Architectural Awareness**: All agents consult `/documentation/main/` docs
- **Human control**: You approve every major decision

### Safety First
- **Automatic checks**: Prevents dangerous mistakes before they happen
- **Permission system**: Controls what Claude can do without asking
- **Quality gates**: Forces proper testing and review processes
- **Architectural validation**: Ensures changes align with established patterns
- **Token enforcement**: Workflow tokens must be properly formatted
- **Context monitoring**: Warns when plans get too large for reliable processing
- **Scope validation**: Repair operations validate file paths exist before proceeding

### Parallel Work
- **Multiple Claude instances**: Work on different features simultaneously
- **Git worktrees**: Keep separate code branches organized
- **Code + review at same time**: One Claude codes, another reviews

### Enterprise-Grade Quality Assurance
- **Comprehensive Testing Suite**: Database integrity, workflow execution, security hardening, enterprise features
- **Three-Tier Rules System**: Hierarchical rules for optimal token usage and specialization
- **Automated Quality Assessment**: Self-assessment with confidence scoring and improvement recommendations
- **Skeptical Validation**: Assumption challenging with evidence-based decision making
- **Browser-First Validation**: UI testing with visual regression and accessibility compliance
- **Performance Optimization**: Async patterns, caching, and resource efficiency
- **Dependency Research**: Thorough evaluation of third-party libraries and services

## Architectural Documentation System

Your AI team maintains architectural consistency through a central documentation system:

### The `/documentation/main/` Folder
This folder contains your project's architectural "source of truth":

```
documentation/main/
‚îú‚îÄ‚îÄ proposedarchitecture.md     # Core architectural decisions
‚îú‚îÄ‚îÄ [other architectural docs]  # API patterns, data models, etc.
```

### How It Works
- **Planning Phase**: Agents read `proposedarchitecture.md` to align new features
- **Implementation**: Code follows established patterns from these documents
- **Review Phase**: Evaluator checks architectural consistency
- **Evolution**: Documents get updated when new patterns are established

### Key Documents
- **`proposedarchitecture.md`**: Technology choices, design patterns, coding standards
- **API Documentation**: How endpoints should be designed
- **Data Models**: Database schema patterns and conventions

### Why This Matters
- **Consistency**: Every feature follows the same architectural patterns
- **Scalability**: Large teams can work without conflicting approaches
- **Maintenance**: Clear documentation of why decisions were made
- **Evolution**: Architecture grows organically with your project

## File Structure After Setup

```
your_project/
‚îú‚îÄ‚îÄ CLAUDE.md                         # ‚ö†Ô∏è  CRITICAL: Auto-loaded context
‚îú‚îÄ‚îÄ .claude/
‚îÇ   ‚îú‚îÄ‚îÄ CLAUDE.md                     # Core invariants + operational procedures
‚îÇ   ‚îú‚îÄ‚îÄ rules/                        # Task-specific rules (7 main + 16 sub-rules)
‚îÇ   ‚îú‚îÄ‚îÄ skills/                       # AI specialist skills (12 comprehensive skills)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ planner.md                # Planning specialist (YAML frontmatter format)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ coder.md                  # Implementation specialist
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tester.md                 # Testing specialist
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ evaluator.md              # Evaluation specialist
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sanity-checker.md         # Reality validation specialist
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ architect-reviewer.md     # Architecture consistency specialist
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ qa-enforcer.md            # Choice elimination specialist
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui-validator.md           # UI testing automation specialist
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dependency-researcher.md  # External dependency specialist
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ self-assessor.md          # Quality self-assessment specialist
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ skeptic.md                # Assumption challenger and validator
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ async-optimizer.md        # Performance optimization specialist
‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ safety_pre_tool.py        # Safety validation hook
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation_post_tool.py   # Minimal feedback hook
‚îÇ   ‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ implement.md              # Main workflow command (Ralph Wiggum gates)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test-plan.md              # Plan validation command
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repair.md                 # Repair workflow command
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ debug-issue.md            # Debugging command
‚îÇ   ‚îú‚îÄ‚îÄ repair_lock.json              # HARD repair scope lock
‚îÇ   ‚îî‚îÄ‚îÄ settings.json                 # Claude Code configuration (hooks + permissions)
‚îú‚îÄ‚îÄ documentation/
‚îÇ   ‚îú‚îÄ‚îÄ main/                         # Architectural source of truth
‚îÇ   ‚îî‚îÄ‚îÄ plans/                        # Generated plan files
‚îú‚îÄ‚îÄ logs/                             # Enterprise audit logging
‚îú‚îÄ‚îÄ temp/                             # Temporary files
‚îî‚îÄ‚îÄ tests/
    ‚îî‚îÄ‚îÄ poc_scripts/                  # Proof of concept test scripts
```

## How to Use It

### Step 1: Start Claude Code
Open your terminal/command prompt and start the AI assistant.

```bash
# Go to your project folder
cd your-project-folder

# Start Claude Code
claude
```

You'll see Claude Code start up and show a prompt where you can type commands.

### Step 2: Choose Your Starting Point

**New Project?** Start with architecture setup:
```bash
/implement "Initialize project architecture for a web application"
```

**Existing Project?** First collect knowledge, then implement:
```bash
/collect-knowledge "Integrate existing project documentation"
/implement "Add user authentication to existing app"
```

### Step 3: The AI Team Workflow

When you type `/implement`, your **12 AI specialists** work together in phases:

#### Phase 1: Planning & Architecture ü§î
- **Planner** creates detailed implementation plan
- **Architect Reviewer** validates against existing patterns
- **QA Enforcer** ensures no open architectural decisions
- **Human Approval**: Type `APPROVE_PLAN` to continue

#### Phase 2: Code Implementation üíª
- **Coder** writes production-ready code with tests first
- **Dependency Researcher** validates external libraries
- **Async Optimizer** ensures performance patterns
- **Human Approval**: Type `APPROVE_CODE_WRITE` to continue

#### Phase 3: Quality Assurance üß™
- **Tester** runs comprehensive tests with real data
- **Sanity Checker** validates UI/data coherence
- **Self-Assessor** provides quality scoring (0-100)
- **Human Approval**: Type `APPROVE_EVALUATION` to continue

#### Phase 4: Ralph Wiggum Iterative Refinement üîÑ
**The secret sauce - automated improvement loops!**

After initial implementation, Claude enters **Ralph Wiggum mode**:
- Tracks progress in `/temp/progress.txt`
- Iteratively improves code until perfect
- **Promise ‚Üí Working ‚Üí Done** cycle for each refinement
- Self-corrects issues without human intervention
- Maximum 50 iterations with human escalation if needed

**You see markers like:**
```
READY_FOR_TESTER
EVALUATION_COMPLETE
SANITY_CHECK_PASS
```

### Step 4: Key Commands for Different Situations

#### üöÄ `/implement "feature description"` - BUILD COMPLETE FEATURES
**PRIMARY COMMAND** - Your main workflow starter
```bash
/implement "build a user registration system with email verification"
/implement "add shopping cart functionality"
/implement "create admin dashboard with analytics"
```

**Triggers Full AI Team Workflow:**
1. Planning ‚Üí Architecture ‚Üí Implementation ‚Üí Testing ‚Üí Evaluation
2. Ralph Wiggum iterative refinement for perfection
3. Human approval gates at key decision points

**When to Use:**
- ‚úÖ New feature development
- ‚úÖ Major functionality additions
- ‚úÖ Complete system components

#### üîß `/repair "what broke"` - FIX SPECIFIC ISSUES
**When something breaks during or after development**
```bash
/repair "login validation not working in Firefox"
/repair "API endpoint returning 500 errors"
/repair "database connection failing after deployment"
```

**Provides Surgical Fixes:**
- Isolates exact problem scope
- Prevents unintended side effects
- Re-tests only affected functionality
- Hard scope enforcement (can't modify unrelated code)

**When to Use:**
- ‚úÖ After `/implement` reveals issues
- ‚úÖ Production bug fixes
- ‚úÖ Targeted improvements

#### üîç `/debug-issue "problem description"` - SYSTEMATIC DEBUGGING
**For complex debugging with browser verification**
```bash
/debug-issue "API calls failing after user login"
/debug-issue "UI not updating after form submission"
/debug-issue "performance degradation on product pages"
```

**Comprehensive Debug Process:**
- Enables debug mode and logging
- Browser console analysis
- Step-by-step issue reproduction
- Root cause identification and fix

**When to Use:**
- ‚úÖ Multi-component issues
- ‚úÖ Browser-specific problems
- ‚úÖ Performance investigations

#### üìã `/test-plan` - PLAN QUALITY VALIDATION
**Before approving implementation plans**
```bash
/test-plan  # Validates current PLAN.md
```

**Validates Plan Quality:**
- Checks architectural compliance
- Verifies TDD requirements
- Ensures database safety
- Confirms human control points

**When to Use:**
- ‚úÖ After initial plan creation
- ‚úÖ Before major implementation approval
- ‚úÖ When reviewing complex plans

#### üìö `/collect-knowledge "context description"` - PROJECT INTEGRATION
**For existing projects - gathers and integrates documentation**
```bash
/collect-knowledge "Ingest existing API documentation and architecture"
/collect-knowledge "Learn current database schema and patterns"
/collect-knowledge "Understand existing testing and deployment processes"
```

**Knowledge Integration:**
- Reads `documentation/main/` folder
- Analyzes existing codebase patterns
- Makes architectural knowledge available to all AI specialists
- Updates CLAUDE.md with project-specific context

**When to Use:**
- ‚úÖ Adding to existing projects
- ‚úÖ After significant architectural changes
- ‚úÖ Before complex feature implementations

### Step 5: Understanding Ralph Wiggum - The Iterative Refinement System

**Ralph Wiggum is your AI team's secret weapon for perfection!** üîÑ

#### How It Works
After initial implementation, Claude enters **iterative improvement mode**:

```
Planning ‚Üí Initial Code ‚Üí Ralph Loop ‚Üí Perfection
                      ‚Üì
               üîÑ ITERATE UNTIL PERFECT üîÑ
                      ‚Üì
            Testing ‚Üí Fixing ‚Üí Re-testing
```

#### What You'll See
**Progress Tracking:**
```
ü§ñ Starting feature implementation...
üìã PLAN CREATED: documentation/plans/plan_001.md
‚ö†Ô∏è Type: APPROVE_PLAN
[... planning phases ...]
üíª Code implementation starting...
üîÑ Ralph Wiggum: Entering iterative refinement mode
üìä Progress: temp/progress.txt updated
‚úÖ READY_FOR_TESTER (iteration 1)
üß™ Testing phase...
‚ö†Ô∏è Issues found, auto-correcting...
‚úÖ READY_FOR_TESTER (iteration 2)
üîÑ Ralph continues until perfect...
üéâ EVALUATION_COMPLETE - Feature ready!
```

#### The Promise/Done Protocol
- **Promise**: "I will implement this feature perfectly"
- **Working**: Active coding and refinement
- **Done**: Feature meets all quality standards
- **Progress**: Tracked in `/temp/progress.txt`

#### Human Control Points
- **Iteration Limits**: Max 50 cycles, human intervention at 40
- **Quality Gates**: Must pass confidence scoring (‚â•80)
- **Escalation**: Human approval for complex issues
- **Memory Management**: `/clear` commands prevent context drift

#### When Ralph Wiggum Activates
- ‚úÖ After initial `/implement` planning phases
- ‚úÖ During complex feature development
- ‚úÖ When quality issues are detected
- ‚úÖ For performance optimization needs

**Ralph Wiggum means you get enterprise-quality results with minimal human intervention!** üéØ

### Step 7: What You'll Experience

**The AI Team Workflow in Action:**

#### Initial Response
```
ü§ñ Starting feature implementation: add a login system...

üìã PLAN CREATED: documentation/plans/2025-01-08_plan_001_login_system.md

‚ö†Ô∏è  HUMAN APPROVAL NEEDED:
Type: APPROVE_PLAN
```

#### Planning Phases
```
üßπ Memory cleared. Ready for next phase.

ü§ñ Architect Reviewer: Validating architectural patterns...
‚úÖ QA Enforcer: No open decisions detected
‚ö†Ô∏è  HUMAN APPROVAL NEEDED:
Type: APPROVE_FINAL_PLAN
```

#### Ralph Wiggum Iterative Refinement
```
üîÑ Ralph Wiggum: Entering iterative refinement mode
üìä Progress tracking: temp/progress.txt

üíª Coder: Writing initial implementation...
üß™ Tester: Running test suite...
‚ö†Ô∏è  Issues detected, auto-correcting...

‚úÖ READY_FOR_TESTER (iteration 1)
üîÑ Ralph continues improving...

‚úÖ SANITY_CHECK_PASS
üéâ EVALUATION_COMPLETE - Feature production-ready!
```

This continues until the feature is complete!

### Step 4: Fixing Problems
If something breaks during development:

```bash
/repair "login button not working in browser test"
```

**What happens**: Claude will focus only on fixing that specific problem, re-test it, and continue.

### Step 5: Memory Management (Important!)
Claude Code can get "confused" if it remembers too many things at once. Always type `/clear` when Claude tells you to:

```bash
# Example: After approving a plan
APPROVE_PLAN

# Claude will say:
/clear

# You type:
/clear

# Then Claude continues with the next step
```

**Why this matters**: Prevents Claude from mixing up ideas between planning and coding phases.

### Advanced: Multiple Claude Teams (For Big Projects)

For really big features, you can run multiple Claude Code instances at the same time, like having several development teams working in parallel.

#### Method 1: Separate Features
If your big feature has independent parts:

```bash
# Create separate folders for each part
git worktree add ../login-backend backend-login
git worktree add ../login-frontend frontend-login

# Start one Claude for backend work
cd ../login-backend && claude /implement "build login API server"

# Start another Claude for frontend work (in a new terminal)
cd ../login-frontend && claude /implement "build login web page"
```

**Result**: Two Claude teams build different parts at the same time.

#### Method 2: Code + Review at Same Time
One Claude writes code, another Claude reviews it simultaneously:

```bash
# Terminal 1: Claude writes the code
claude "invoke @Coder to implement the login system"

# Terminal 2: Different Claude reviews (open new terminal)
/clear
claude "Review the login code and check for security issues"
```

**Result**: Faster development with built-in code review.

### Security Settings (What Claude Can Do)

Claude Code follows a "secure by default" approach - it asks permission for dangerous actions.

```json
{
  "permissions": {
    "Read": "allow",        // Claude can read files without asking
    "Grep": "allow",        // Claude can search text without asking
    "Glob": "allow",        // Claude can list files without asking
    "Edit": "prompt",       // Claude MUST ask before changing any code
    "Bash": {
      "git status": "allow",    // Safe: just shows git status
      "git diff": "allow",      // Safe: shows changes
      "npm test": "prompt",     // Dangerous: running tests needs approval
      "python -m pytest": "prompt" // Dangerous: running tests needs approval
    }
  }
}
```

**Why these settings?**
- **Reading/Searching: Allowed** - These are safe operations that don't change anything
- **Code Changes: Need Approval** - You must confirm every code edit (the main safety feature)
- **Test Running: Need Approval** - Tests might change databases or files, so you approve them
- **Git Commands: Carefully Controlled** - Read-only git commands are OK, write commands are blocked

### Context Management Best Practices

```bash
# Clear context between major workflow shifts
/clear

# Use checklists for complex multi-step tasks
claude "Create a markdown checklist for the 10-step migration plan"
```

### MCP Integration (Optional)

For advanced UI testing and external integrations, configure MCP servers:

```json
// .mcp.json
{
  "mcpServers": {
    "puppeteer": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-puppeteer"],
      "env": {
        "HEADLESS": "true"
      }
    }
  }
}
```

### Individual Subagent Usage

```bash
# Use subagents directly for specific tasks
claude "delegate to Planner: Plan the database schema for user management"
claude "delegate to Coder: Implement the login API endpoint"
claude "delegate to Tester: Test the user registration flow"
claude "delegate to Evaluator: Review the authentication implementation"
```

## Configuration Customization

### Modifying Global Rules

Edit `CLAUDE.md` to customize operational procedures:

```yaml
global_rules:
  - No database resets/drops/duplicates
  - Async preferred; use get_db_session_context()
  - TDD gates: Tests in /tests/ folder, no mocks, real data
  # Add your project-specific rules here
```

### Adjusting Safety Settings

```yaml
safety:
  protected_files:
    - .env
    - .github/workflows/*.yml
    # Add your protected files
```

### Workflow Tuning

```yaml
workflow:
  max_agent_iterations: 5  # Increase for complex tasks
  human_intervention_timeout: 300  # Seconds to wait for human input
```

## Meet Your AI Team

### Core Development Team

#### The Planner ü§î
**Job**: Creates detailed plans before any coding starts
**What they do**:
- Researches your existing code to understand what you have
- Writes step-by-step plans in `documentation/plans/`
- Makes sure the plan covers everything needed
- Asks you questions to improve the plan

#### The Coder üíª
**Job**: Writes the actual code following the plan
**What they do**:
- Reads the plan and writes code to match it exactly
- Creates tests first, then writes code to pass those tests
- Makes only the changes needed (no extra stuff)
- Shows you exactly what files they changed

#### The Tester üß™
**Job**: Makes sure everything works correctly
**What they do**:
- Runs all kinds of tests (unit tests, integration tests, UI tests)
- Uses real data, not fake test data
- Checks that the code works in browsers and with databases
- Reports any problems found and how to fix them

#### The Evaluator ‚úÖ
**Job**: Final review and quality check
**What they do**:
- Reviews all the code, tests, and results
- Checks that everything meets your standards
- Calculates how complete the work is
- Gives final approval or asks for fixes

### Quality Assurance Specialists

#### The Sanity Checker üîç
**Job**: Reality auditor for UI/data coherence
**What they do**:
- Performs browser-first validation with visual evidence
- Checks for N/A, NaN, null values in UI and data
- Validates console errors, network failures, and logical consistency
- Issues SANITY_CHECK_PASS tokens based on visual evidence

#### The Architect Reviewer üèóÔ∏è
**Job**: Architecture consistency validator
**What they do**:
- Ensures all implementations align with established patterns
- Validates domain boundaries and layer isolation
- Checks SOLID principles and dependency directions
- Prevents architectural drift and maintains consistency

#### The QA Enforcer üö´
**Job**: Choice elimination enforcer
**What they do**:
- Blocks any output containing unresolved architectural decisions
- Detects forbidden patterns like "could," "might," or "TBD"
- Enforces evidence-based decision making
- Requires definitive yes/no decisions with justifications

#### The UI Validator üé®
**Job**: UI testing automation specialist
**What they do**:
- Performs visual regression testing and functional validation
- Tests accessibility compliance and cross-browser compatibility
- Measures Core Web Vitals and performance metrics
- Ensures visual accuracy and user experience quality

### Research and Optimization Specialists

#### The Dependency Researcher üî¨
**Job**: External dependency specialist
**What they do**:
- Researches and evaluates third-party libraries and services
- Performs comprehensive market analysis and technical evaluation
- Assesses security, performance, and maintenance viability
- Provides evidence-based recommendations with migration guidance

#### The Self-Assessor üìä
**Job**: Quality self-assessment expert
**What they do**:
- Provides automated code quality scoring (0-100 scale)
- Analyzes structure, readability, maintainability, and reliability
- Generates targeted improvement recommendations
- Tracks quality trends and identifies technical debt

#### The Skeptic ü§®
**Job**: Assumption challenger and validator
**What they do**:
- Challenges unstated assumptions with evidence-based validation
- Performs web research to verify technical and business claims
- Detects cognitive biases in decision-making processes
- Ensures decisions are based on verified facts, not beliefs

#### The Async Optimizer ‚ö°
**Job**: Performance optimization specialist
**What they do**:
- Identifies I/O-bound and CPU-bound optimization opportunities
- Implements async patterns, caching, and resource management
- Provides performance monitoring and automated recommendations
- Optimizes for concurrency, memory usage, and response times

## Safety Features

### Automatic Guards
The system has safety programs that run automatically:

### Before Actions (Pre-Tool Guard)
- **Stops dangerous commands**: Prevents deleting files, formatting disks, etc.
- **Cache cleanup allowed**: Can delete `__pycache__` and `node_modules/.cache` folders
- **Worktree protection**: Claude can only change files in the current project area
- **File protection**: Important files like `.env` can't be accidentally changed
- **Size limits**: Warns about very large files

### After Actions (Post-Tool Guard)
- **Error detection**: Catches crashes, failed tests, and exceptions
- **Lazy code detection**: Finds placeholder comments like "add code here"
- **Workflow stops**: Prevents continuing if serious problems found
- **Clear feedback**: Tells you exactly what went wrong and what to do

## How the Team Works Together

### The `/implement` Process
When you type `/implement "build a chat app"`, here's what happens:

1. **Planning** üìã
   - Planner creates a detailed plan
   - You review and approve it

2. **Coding** üíª
   - Coder writes the actual code
   - Tests are written first, then code

3. **Testing** üß™
   - Tester runs all tests and checks everything works
   - Uses real data and browsers

4. **Review** ‚úÖ
   - Evaluator checks quality and gives final approval

### What If Something Goes Wrong?
- **Auto-retry**: Failed steps try again automatically
- **Human help**: Serious problems stop and ask for your guidance
- **Fix command**: Use `/repair "what broke"` to fix specific issues
- **Logging**: Everything is tracked so you can see what happened

## Best Practices

### Project Setup
- Always copy the complete setup structure
- Customize CLAUDE.md operational procedures for your project's needs
- Test the setup with a simple feature first

### Workflow Usage
- Use `/implement` for complete features
- Individual subagents for specific tasks
- Review plans before approving implementation
- Never commit without human review

### Maintenance
- Update global rules as project evolves
- Monitor hook effectiveness and adjust safety settings
- Review workflow metrics and optimize iteration limits

## Troubleshooting

### Common Issues

**Subagent not responding**:
- Check YAML syntax in subagent definitions
- Verify file permissions on plugin scripts
- Ensure Claude Code can access .claude directory

**Safety hook blocking valid operations**:
- Review safety context in CLAUDE.md
- Check for false positives in safety patterns
- Adjust safety settings for your environment

**Workflow hanging**:
- Check operational procedures in CLAUDE.md
- Review timeout settings
- Examine logs for stuck operations

**Plan validation failing**:
- Ensure documentation/plans/ directory exists
- Check required sections in PLAN.md format
- Verify file permissions

### Debug Mode

Enable detailed logging by adding to CLAUDE.md operational procedures:
```yaml
debug:
  enable_logging: true
  log_level: DEBUG
  log_file: .claude/debug.log
```

## Metrics and Monitoring

### Built-in Metrics
- Phase completion times
- Error rates and recovery success
- Test coverage and quality scores
- Human intervention frequency

### Monitoring Commands
```bash
# View recent workflow executions
claude "show workflow history"

# Check subagent performance
claude "analyze subagent metrics"

# Review safety hook activity
claude "show safety incidents"
```

## Support and Extension

### Adding Custom Subagents
1. Create new YAML file in `.claude/subagents/`
2. Define role, expertise, and prompt template
3. Add to workflow orchestration if needed

### Creating Custom Commands
1. Create markdown file in `.claude/commands/`
2. Define description and argument hints
3. Include orchestration instructions

### Extending Safety Rules
1. Modify `safety_pre_tool.py` for new validations
2. Update CLAUDE.md safety context with additional protected patterns
3. Test thoroughly before deployment

---

## üöÄ AUTOMATED SETUP (Much Easier!)

**OR YOU CAN DO ALL THIS AUTOMATICALLY** with one command instead of copying files manually!

### Quick Automated Setup

```bash
# 1. Set where you want to install (replace with your project path)
export CC_DESTINATION=/path/to/your/project

# 2. Run the automated setup script
./scripts/setup.sh
```

**What the script does automatically:**
- ‚úÖ Copies CLAUDE.md to your project
- ‚úÖ Creates all `.claude/` folders
- ‚úÖ Copies 12 AI specialist skills
- ‚úÖ Copies 7 main rules + 16 sub-rules
- ‚úÖ Copies safety programs (hooks)
- ‚úÖ Copies special commands
- ‚úÖ Sets up security settings
- ‚úÖ Creates work directories
- ‚úÖ Sets proper permissions
- ‚úÖ Verifies everything worked

**Example usage:**
```bash
# For a project in your home directory
export CC_DESTINATION=~/my-awesome-app
./scripts/setup.sh

# Or for current directory
export CC_DESTINATION=.
./scripts/setup.sh
```

**What you'll see:**
```
‚ÑπÔ∏è  Setting up Claude Code environment in: /home/user/my-awesome-app
‚ÑπÔ∏è  Step 1: Copying CLAUDE.md (project memory file)...
‚úÖ CLAUDE.md copied to project root
‚ÑπÔ∏è  Step 2: Creating .claude directory structure...
‚úÖ .claude directories created
[...more steps...]
üéâ Claude Code Multi-Agent Setup Complete!

What you can do now:
  1. Go to your project: cd /home/user/my-awesome-app
  2. Start Claude: claude
  3. Try your first feature: /implement "add a simple game"
```

**That's it!** The script handles all setup steps for you.

---

## üöÄ POST-INSTALLATION: Getting Started Checklist

**After setup is complete, here's how to start using your AI development team:**

### ‚úÖ Step 1: Verify Setup Success
```bash
# Check that all files are in place
find .claude/ -name "*.md" | wc -l  # Should show ~40 files

# Verify Claude Code can access your setup
claude --help
```

### ‚úÖ Step 2: Choose Your Starting Point

**For New Projects:**
```bash
# Initialize project architecture
/implement "Initialize project architecture for a [describe your app type]"
# Follow approval prompts (APPROVE_PLAN, etc.)
```

**For Existing Projects:**
```bash
# First, let AI team learn your existing architecture
/collect-knowledge "Integrate existing project documentation and patterns"

/implement "Add [new feature] to existing [describe your project]"
```

### ‚úÖ Step 3: Learn the Approval Flow
When you run `/implement`, you'll see prompts like:
```
‚ö†Ô∏è HUMAN APPROVAL NEEDED:
Type: APPROVE_PLAN
```
**Always read the plan/docs first, then type the approval command.**

### ‚úÖ Step 4: Master Memory Management
Claude will prompt you to type `/clear` between major phases:
```
üßπ Memory cleared. Ready for next phase.
```
**This prevents context confusion - always do it when instructed!**

### ‚úÖ Step 5: Understand Progress Indicators
Watch for these signs of success:
- ‚úÖ `READY_FOR_TESTER` - Code implementation complete
- ‚úÖ `SANITY_CHECK_PASS` - UI/data validation successful
- ‚úÖ `EVALUATION_COMPLETE` - Feature production-ready
- üîÑ `Ralph Wiggum: Entering iterative refinement mode` - Auto-improvement active

### ‚úÖ Step 6: Know When to Use Each Command

| Situation | Command | Example |
|-----------|---------|---------|
| **New feature** | `/implement "feature"` | `/implement "add user login"` |
| **Bug fix** | `/repair "issue"` | `/repair "login button broken"` |
| **Complex debugging** | `/debug-issue "problem"` | `/debug-issue "API timeout errors"` |
| **Plan review** | `/test-plan` | `/test-plan` |
| **Project integration** | `/collect-knowledge "context"` | `/collect-knowledge "learn existing APIs"` |

### ‚úÖ Step 7: Monitor Quality Gates
Your AI team enforces enterprise standards:
- **Confidence Scores**: Must be ‚â•80
- **Test Coverage**: Real data testing required
- **Architectural Compliance**: Follows established patterns
- **Security**: No dangerous operations allowed

### ‚úÖ Step 8: Scale to Multiple Features
For bigger projects, run parallel development:
```bash
# Terminal 1: Backend work
claude /implement "build API endpoints"

# Terminal 2: Frontend work (in new terminal)
/clear  # Start fresh
claude /implement "build user interface"
```

### üéØ Success Indicators
- **Plans created** in `documentation/plans/`
- **Code written** with proper structure
- **Tests passing** with real data
- **Quality scores** ‚â•80 confidence
- **Human approvals** at appropriate checkpoints

**Remember: You're the human conductor of this AI orchestra. Guide with approvals, but let Ralph Wiggum handle the perfection!** üéºü§ñ

---

**Welcome to AI-powered development! Your team of 12 specialists is ready to build production-quality software with you.** üöÄ‚ú®

### Manual Setup (Alternative)

If you prefer to do it step by step, follow the detailed instructions above.

## Check Your Setup Worked

After setup (manual or automatic), verify everything is ready:

```bash
# Count the files you copied (should show about 46 files)
find .claude/ -type f | wc -l

# Check the key files are there
ls -la .claude/settings.json
ls -la .claude/subagents/
ls -la .claude/hooks/
ls -la .claude/commands/
```

### If `/implement` Doesn't Work
Sometimes the special commands don't load. Here's how to do it manually:

```bash
# Start Claude normally
claude

# Tell Claude what to do step by step:
# Type: "Use @Planner to create a plan for: add a login system"
# Wait for Claude to respond, then type: APPROVE_PLAN
# Type: /clear (when Claude tells you to)
# Continue with each approval step...
```

## Production Readiness Checklist

### Pre-Deployment Verification
- [ ] All 12 skills implemented with proper YAML frontmatter and forked contexts
- [ ] All 7 main rules + 16 sub-rules implemented and functional
- [ ] Comprehensive testing completed (database integrity, workflow execution, security hardening, enterprise features)
- [ ] Database integrity testing passed with real data preservation verified
- [ ] Workflow execution testing completed end-to-end with all gates functional
- [ ] Security hardening validated (rm ban, worktree isolation, repair scope enforcement)
- [ ] Enterprise features tested (multi-agent coordination, audit logging, compliance)
- [ ] Implementation plan updated to reflect 100% completion status
- [ ] README.md updated with accurate status and comprehensive troubleshooting

### Deployment Checklist
- [ ] Set `CC_DESTINATION` environment variable to target project directory
- [ ] Execute `./scripts/setup.sh` and verify successful completion
- [ ] Verify all 46 files installed correctly
- [ ] Test Claude Code initialization: `claude`
- [ ] Verify `.claude/` directory structure with all subdirectories
- [ ] Confirm architectural documentation created in `documentation/main/`
- [ ] Validate repair_lock.json properly initialized
- [ ] Test safety hooks are executable and functional

### Post-Deployment Testing
- [ ] Execute `/implement "create user registration system"` end-to-end
- [ ] Verify all workflow gates execute properly (A through F)
- [ ] Confirm context resets work at each human gate
- [ ] Test sanity checker integration for UI features
- [ ] Validate Ralph loop functionality and progress tracking
- [ ] Check multi-agent coordination and parallel operation
- [ ] Verify audit logging captures complete operation trail

### Rollback Procedures
**If deployment fails or issues are discovered:**

1. **Immediate Stop**: Stop all Claude Code instances
2. **Isolate Changes**: Move `.claude/` directory to backup location
3. **Restore Previous State**: Revert any modified project files
4. **Clean Environment**: Remove any test data or artifacts
5. **Report Issues**: Document specific failures for investigation
6. **Selective Re-deployment**: Address issues and redeploy incrementally

**Rollback Commands:**
```bash
# Backup current setup
mv .claude .claude.backup.$(date +%Y%m%d_%H%M%S)

# Restore previous CLAUDE.md if needed
git checkout HEAD~1 -- CLAUDE.md

# Clean test artifacts
rm -rf temp/ logs/ documentation/plans/*
```

## Your First Test - Quick Checklist

**For Automated Setup:**
- [ ] Set `CC_DESTINATION` environment variable
- [ ] Ran `./scripts/setup.sh` successfully
- [ ] Claude Code works when you type `claude`
- [ ] You can see the `.claude/` folder with all subfolders
- [ ] Try: `/implement "make a simple calculator web page"`

**For Interactive Setup:**
- [ ] Ran `./scripts/setup-interactive.sh` and answered questions
- [ ] Setup completed with your custom configuration
- [ ] Claude Code works when you type `claude`
- [ ] Check that documentation was set up according to your answers
- [ ] Try: `/implement "make a simple calculator web page"`

**Both Methods - Verify Everything Works:**
- [ ] You can see `documentation/main/`, `documentation/plans/`, and `tests/poc_scripts/` folders
- [ ] Check that `documentation/main/proposedarchitecture.md` was created
- [ ] Watch how Claude asks for approvals at each step
- [ ] Notice how Claude references your architectural documents
- [ ] Test `/collect-knowledge` if you have existing docs
- [ ] Try `/debug-issue` and `/test-plan` commands

---

*This setup turns Claude Code into a full development team that works with you. Start with simple features to learn how it works, then use it for bigger projects. Remember: you control all the important decisions - Claude Code is your smart assistant, not your replacement.*
